<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event-Day Run Planner</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            brand: '#194D33',
            'brand-dark': '#0f2c1b'
          },
          fontFamily: {
            sans: ['Inter', 'sans-serif']
          }
        }
      }
    };
  </script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="m-0 block bg-white px-4 py-8 font-sans text-brand sm:px-8">
  <div id="root"></div>

  <script type="text/babel">
window.RunningPlan = window.RunningPlan || {};

window.RunningPlan.DISTANCE_OPTIONS = [
  { value: "10k", label: "10km", km: 10, minDays: 28 },
  { value: "half", label: "Half marathon", km: 21.1, minDays: 42 },
  { value: "full", label: "Full marathon", km: 42.2, minDays: 90 },
];

window.RunningPlan.STRENGTH_EXERCISES = [
  "Squats",
  "Walking lunges",
  "Step-ups",
  "Single-leg RDL",
  "Calf raises",
  "Hip thrusts",
  "Glute bridges",
  "Wall sits",
  "Bulgarian split squats",
  "Box jumps",
];

window.RunningPlan.DISCLAIMER_TITLE = "Important health and safety disclaimer";
window.RunningPlan.DISCLAIMER_LINES = [
  "This tool is for general informational and educational perusal only. It is not medical advice, diagnosis, treatment, physiotherapy guidance, or coaching instruction.",
  "This planner may be more useful for people who are already active and very fit, but it can still be inappropriate or unsafe for your personal context.",
  "You must consult a licensed physician and a qualified physiotherapist or certified trainer before starting, changing, or intensifying training.",
  "By proceeding, you acknowledge that any use is fully at your own risk. The site owner, author, and contributors disclaim all liability for injuries, health events, losses, or damages of any kind resulting from use or misuse of this tool.",
];

window.RunningPlan.RISK_ACCEPTED_BANNER = "You accepted to use this at your own risk.";
window.RunningPlan.TIME_TRAVEL_MSG = "Good luck time travelling :) ";
window.RunningPlan.AMBITIOUS_PLAN_MSG = "we can't generate that ambitious a plan :) ";
window.RunningPlan.SHARE_BASE_URL = "https://igorcarreira.pt/tools/running-plan";

if (typeof module !== "undefined" && module.exports) {
  module.exports = {
    DISTANCE_OPTIONS: window.RunningPlan.DISTANCE_OPTIONS,
    STRENGTH_EXERCISES: window.RunningPlan.STRENGTH_EXERCISES,
    DISCLAIMER_TITLE: window.RunningPlan.DISCLAIMER_TITLE,
    DISCLAIMER_LINES: window.RunningPlan.DISCLAIMER_LINES,
    RISK_ACCEPTED_BANNER: window.RunningPlan.RISK_ACCEPTED_BANNER,
    TIME_TRAVEL_MSG: window.RunningPlan.TIME_TRAVEL_MSG,
    AMBITIOUS_PLAN_MSG: window.RunningPlan.AMBITIOUS_PLAN_MSG,
    SHARE_BASE_URL: window.RunningPlan.SHARE_BASE_URL,
  };
}
  </script>

  <script type="text/babel">
window.RunningPlan = window.RunningPlan || {};

window.RunningPlan.utils = {
  DAY_NAMES: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  SHARE_TYPE_DICTIONARY: [
    "Rest Day",
    "Strength Training",
    "HIIT Indoor Cycling",
    "Long Indoor Cycling",
    "Outdoor Slow Run",
    "Outdoor Sprint Strides",
    "EVENT DAY",
  ],
  MONTH_DICTIONARY: {
    Jan: 0,
    Feb: 1,
    Mar: 2,
    Apr: 3,
    May: 4,
    Jun: 5,
    Jul: 6,
    Aug: 7,
    Sep: 8,
    Oct: 9,
    Nov: 10,
    Dec: 11,
  },

  getDistanceMeta(distanceValue) {
    return (
      (window.RunningPlan.DISTANCE_OPTIONS || []).find((d) => d.value === distanceValue) || null
    );
  },

  parseDateInput(dateStr) {
    const source = String(dateStr || "").trim();
    const match = source.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!match) return null;

    const year = Number(match[1]);
    const month = Number(match[2]);
    const day = Number(match[3]);
    const parsed = new Date(year, month - 1, day);

    if (Number.isNaN(parsed.getTime())) return null;
    if (
      parsed.getFullYear() !== year ||
      parsed.getMonth() !== month - 1 ||
      parsed.getDate() !== day
    ) {
      return null;
    }

    parsed.setHours(0, 0, 0, 0);
    return parsed;
  },

  parseDateLabel(dateLabel) {
    const source = String(dateLabel || "").trim();
    const match = source.match(/^(\d{1,2}) ([A-Za-z]{3}) (\d{4})$/);
    if (!match) return null;

    const day = Number(match[1]);
    const month = this.MONTH_DICTIONARY[match[2]];
    const year = Number(match[3]);

    if (month === undefined) return null;

    const parsed = new Date(year, month, day);
    if (Number.isNaN(parsed.getTime())) return null;
    if (parsed.getFullYear() !== year || parsed.getMonth() !== month || parsed.getDate() !== day) {
      return null;
    }

    parsed.setHours(0, 0, 0, 0);
    return parsed;
  },

  toDateInput(date) {
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, "0");
    const dd = String(date.getDate()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd}`;
  },

  parseExpectedTime(timeStr) {
    const match = String(timeStr || "")
      .trim()
      .match(/^(\d{1,2}):(\d{2})$/);
    if (!match) return null;

    const hours = Number(match[1]);
    const minutes = Number(match[2]);

    if (Number.isNaN(hours) || Number.isNaN(minutes) || minutes > 59) return null;

    return hours * 60 + minutes;
  },

  getDaysRemaining(dateStr) {
    if (!dateStr) {
      return { daysRemaining: null, isPast: false };
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const eventDate = this.parseDateInput(dateStr);
    if (!eventDate) {
      return { daysRemaining: null, isPast: false };
    }

    const days = this.daysDiffByCalendar(today, eventDate);

    return {
      daysRemaining: days,
      isPast: days < 0,
    };
  },

  formatDate(date) {
    return date.toLocaleDateString("en-GB", {
      day: "numeric",
      month: "short",
      year: "numeric",
    });
  },

  isSameCalendarDay(a, b) {
    return (
      a.getFullYear() === b.getFullYear() &&
      a.getMonth() === b.getMonth() &&
      a.getDate() === b.getDate()
    );
  },

  daysDiffByCalendar(startDate, endDate) {
    const startUtc = Date.UTC(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
    const endUtc = Date.UTC(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
    return Math.floor((endUtc - startUtc) / (1000 * 60 * 60 * 24));
  },

  toShareToken(value, dictionary) {
    const source = String(value || "");
    if (!source) return "";

    const index = Array.isArray(dictionary) ? dictionary.indexOf(source) : -1;
    return index >= 0 ? index : source;
  },

  fromShareToken(token, dictionary) {
    if (typeof token === "number" && Array.isArray(dictionary) && dictionary[token]) {
      return dictionary[token];
    }

    return token || "";
  },

  compactSession(session) {
    const source = session && typeof session === "object" ? session : {};
    const exerciseDictionary = window.RunningPlan.STRENGTH_EXERCISES || [];

    let durationValue = source.duration;
    if (durationValue === undefined || durationValue === null || durationValue === "") {
      durationValue = 0;
    } else if (typeof durationValue === "string" && /^\d+$/.test(durationValue.trim())) {
      durationValue = Number(durationValue.trim());
    }

    const compactExercises = Array.isArray(source.exercises)
      ? source.exercises
          .map((exercise) => this.toShareToken(exercise, exerciseDictionary))
          .filter((exercise) => exercise !== "")
      : [];

    const compactSession = [
      this.toShareToken(source.day, this.DAY_NAMES),
      source.dateLabel || "",
      this.toShareToken(source.type, this.SHARE_TYPE_DICTIONARY),
      durationValue,
      source.description || "",
      compactExercises.length > 0 ? compactExercises : "",
      source.isTaperWeek ? 1 : 0,
    ];

    while (compactSession.length > 0) {
      const tail = compactSession[compactSession.length - 1];
      if (tail === "" || tail === 0) {
        compactSession.pop();
      } else {
        break;
      }
    }

    return compactSession;
  },

  sessionsAreEqual(a, b) {
    return JSON.stringify(this.compactSession(a)) === JSON.stringify(this.compactSession(b));
  },

  expandSession(compactSession) {
    const source = Array.isArray(compactSession) ? compactSession : [];
    const exerciseDictionary = window.RunningPlan.STRENGTH_EXERCISES || [];

    const compactExercises = source[5];
    const exercises =
      Array.isArray(compactExercises) && compactExercises.length > 0
        ? compactExercises.map((exercise) => this.fromShareToken(exercise, exerciseDictionary))
        : null;

    return {
      day: this.fromShareToken(source[0], this.DAY_NAMES),
      dateLabel: source[1] || "",
      type: this.fromShareToken(source[2], this.SHARE_TYPE_DICTIONARY),
      duration: source.length > 3 ? source[3] : 0,
      description: source[4] || null,
      exercises,
      isTaperWeek: Boolean(source[6]),
    };
  },

  toCompactSharePayload(payload) {
    const source = payload && typeof payload === "object" ? payload : {};
    const form = source.form && typeof source.form === "object" ? source.form : {};
    const plan = Array.isArray(source.plan) ? source.plan : [];
    const firstSession = plan[0] && plan[0][0] ? plan[0][0] : null;
    const startDate = firstSession ? this.parseDateLabel(firstSession.dateLabel) : null;
    const expectedTimeMinutes = this.parseExpectedTime(form.expectedTime || "");
    const canBuildBasePlan =
      Boolean(startDate) &&
      Boolean(form.eventDate) &&
      Boolean(form.trainingDaysPerWeek) &&
      Boolean(expectedTimeMinutes);

    if (canBuildBasePlan) {
      const basePlan = this.buildWeeklyPlan({
        eventDateStr: form.eventDate,
        expectedTimeMinutes,
        trainingDaysPerWeek: form.trainingDaysPerWeek,
        startDateStr: this.toDateInput(startDate),
      });

      if (Array.isArray(basePlan) && basePlan.length === plan.length) {
        const edits = [];
        let sameStructure = true;

        for (let weekIndex = 0; weekIndex < plan.length; weekIndex += 1) {
          const sourceWeek = Array.isArray(plan[weekIndex]) ? plan[weekIndex] : [];
          const baseWeek = Array.isArray(basePlan[weekIndex]) ? basePlan[weekIndex] : [];

          if (sourceWeek.length !== baseWeek.length) {
            sameStructure = false;
            break;
          }

          for (let dayIndex = 0; dayIndex < sourceWeek.length; dayIndex += 1) {
            if (!this.sessionsAreEqual(sourceWeek[dayIndex], baseWeek[dayIndex])) {
              edits.push([weekIndex, dayIndex, this.compactSession(sourceWeek[dayIndex])]);
            }
          }
        }

        if (sameStructure) {
          return {
            v: 3,
            n: source.planName || "",
            f: [
              form.eventDate || "",
              form.distance || "",
              form.expectedTime || "",
              form.trainingDaysPerWeek || "",
              this.toDateInput(startDate),
            ],
            e: edits,
          };
        }
      }
    }

    return {
      v: 2,
      n: source.planName || "",
      f: [
        form.eventDate || "",
        form.distance || "",
        form.expectedTime || "",
        form.trainingDaysPerWeek || "",
      ],
      p: Array.isArray(source.plan)
        ? source.plan.map((week) =>
            Array.isArray(week) ? week.map((session) => this.compactSession(session)) : []
          )
        : [],
    };
  },

  fromCompactSharePayload(payload) {
    if (!payload || typeof payload !== "object") {
      return null;
    }

    if (payload.v === 3) {
      const form = Array.isArray(payload.f) ? payload.f : [];
      const baseForm = {
        eventDate: form[0] || "",
        distance: form[1] || "",
        expectedTime: form[2] || "",
        trainingDaysPerWeek: form[3] || "",
      };
      const startDateStr = form[4] || "";
      const expectedTimeMinutes = this.parseExpectedTime(baseForm.expectedTime);

      if (!startDateStr || !expectedTimeMinutes || !baseForm.trainingDaysPerWeek) {
        return null;
      }

      const basePlan = this.buildWeeklyPlan({
        eventDateStr: baseForm.eventDate,
        expectedTimeMinutes,
        trainingDaysPerWeek: baseForm.trainingDaysPerWeek,
        startDateStr,
      });

      const edits = Array.isArray(payload.e) ? payload.e : [];
      edits.forEach((edit) => {
        if (!Array.isArray(edit) || edit.length < 3) return;
        const weekIndex = Number(edit[0]);
        const dayIndex = Number(edit[1]);
        const session = this.expandSession(edit[2]);

        if (
          Number.isNaN(weekIndex) ||
          Number.isNaN(dayIndex) ||
          !basePlan[weekIndex] ||
          !basePlan[weekIndex][dayIndex]
        ) {
          return;
        }

        basePlan[weekIndex][dayIndex] = session;
      });

      return {
        v: 3,
        planName: payload.n || "",
        form: baseForm,
        plan: basePlan,
      };
    }

    if (payload.v !== 2 || !Array.isArray(payload.p)) return null;

    const form = Array.isArray(payload.f) ? payload.f : [];

    return {
      v: 2,
      planName: payload.n || "",
      form: {
        eventDate: form[0] || "",
        distance: form[1] || "",
        expectedTime: form[2] || "",
        trainingDaysPerWeek: form[3] || "",
      },
      plan: payload.p.map((week) =>
        Array.isArray(week) ? week.map((session) => this.expandSession(session)) : []
      ),
    };
  },

  encodeBase64Url(value) {
    const raw = String(value || "");
    let base64 = "";

    if (typeof btoa === "function") {
      base64 = btoa(unescape(encodeURIComponent(raw)));
    } else if (typeof Buffer !== "undefined") {
      base64 = Buffer.from(raw, "utf8").toString("base64");
    } else {
      return "";
    }

    return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  },

  decodeBase64Url(value) {
    try {
      let normalized = String(value || "")
        .replace(/-/g, "+")
        .replace(/_/g, "/");

      while (normalized.length % 4 !== 0) {
        normalized += "=";
      }

      if (typeof atob === "function") {
        return decodeURIComponent(escape(atob(normalized)));
      }

      if (typeof Buffer !== "undefined") {
        return Buffer.from(normalized, "base64").toString("utf8");
      }

      return "";
    } catch (_error) {
      return "";
    }
  },

  encodeSharePayload(payload) {
    try {
      const compactPayload = this.toCompactSharePayload(payload);
      const json = JSON.stringify(compactPayload);
      return this.encodeBase64Url(json);
    } catch (_error) {
      return "";
    }
  },

  decodeSharePayload(encodedPayload) {
    try {
      const decoded = this.decodeBase64Url(encodedPayload);
      if (!decoded) return null;

      const parsed = JSON.parse(decoded);
      return this.fromCompactSharePayload(parsed);
    } catch (_error) {
      return null;
    }
  },

  buildShareUrl(payload) {
    const encoded = this.encodeSharePayload(payload);
    if (!encoded) return "";

    return `${window.RunningPlan.SHARE_BASE_URL}#params=${encodeURIComponent(encoded)}`;
  },

  getSharePayloadFromHash(hash) {
    const source = String(hash || "");
    if (!source || !source.startsWith("#")) return null;

    const query = source.slice(1);
    const params = new URLSearchParams(query);
    const encoded = params.get("params");

    if (!encoded) return null;

    return this.decodeSharePayload(encoded);
  },

  getValidationMessage({ dateStr, distanceValue }) {
    const { daysRemaining, isPast } = this.getDaysRemaining(dateStr);

    if (dateStr && isPast) {
      return window.RunningPlan.TIME_TRAVEL_MSG;
    }

    if (!distanceValue || daysRemaining === null || isPast) {
      return null;
    }

    const distance = this.getDistanceMeta(distanceValue);
    if (!distance) {
      return null;
    }

    if (daysRemaining < distance.minDays) {
      return window.RunningPlan.AMBITIOUS_PLAN_MSG;
    }

    return null;
  },

  buildWeeklyPlan({
    eventDateStr,
    daysRemaining,
    expectedTimeMinutes,
    trainingDaysPerWeek,
    startDateStr,
  }) {
    const today = startDateStr ? this.parseDateInput(startDateStr) : null;
    const startDay = today || new Date();
    startDay.setHours(0, 0, 0, 0);

    const eventDate = eventDateStr ? this.parseDateInput(eventDateStr) : null;

    let totalDays;
    if (eventDate && !Number.isNaN(eventDate.getTime())) {
      totalDays = this.daysDiffByCalendar(startDay, eventDate) + 1;
    } else if (typeof daysRemaining === "number") {
      totalDays = daysRemaining + 1;
    } else {
      totalDays = 0;
    }

    if (totalDays <= 0) {
      return [];
    }

    const totalWeeks = Math.ceil(totalDays / 7);
    const trainingDays = Number(trainingDaysPerWeek);
    const plan = [];

    const minSlowRunDuration = Math.round(expectedTimeMinutes * 0.3);
    const maxSlowRunDuration = expectedTimeMinutes;

    for (let dayOffset = 0; dayOffset < totalDays; dayOffset += 1) {
      const weekIndex = Math.floor(dayOffset / 7);
      if (!plan[weekIndex]) {
        plan[weekIndex] = [];
      }

      const currentDate = new Date(startDay);
      currentDate.setDate(startDay.getDate() + dayOffset);

      const dayName = this.DAY_NAMES[currentDate.getDay()];
      const daysUntilRace = totalDays - dayOffset - 1;
      const isTaperWeek = daysUntilRace > 0 && daysUntilRace <= 7;

      const intensityFactor = 1 + (weekIndex / Math.max(totalWeeks, 1)) * 0.5;
      const hiitDuration = 30 + weekIndex * 5;
      const slowRunDuration =
        minSlowRunDuration +
        Math.round(
          (maxSlowRunDuration - minSlowRunDuration) * (weekIndex / Math.max(totalWeeks - 1, 1))
        );

      let sessionConfigs = [];

      if (trainingDays === 3) {
        sessionConfigs = [
          { type: "Strength Training", day: "Monday" },
          { type: "HIIT Indoor Cycling", day: "Wednesday" },
          { type: "Outdoor Slow Run", day: "Saturday" },
        ];
      } else if (trainingDays === 4) {
        sessionConfigs = [
          { type: "Strength Training", day: "Monday" },
          { type: "HIIT Indoor Cycling", day: "Tuesday" },
          { type: "Outdoor Slow Run", day: "Thursday" },
          { type: "Outdoor Sprint Strides", day: "Saturday" },
        ];
      } else if (trainingDays === 5) {
        sessionConfigs = [
          { type: "Strength Training", day: "Monday" },
          { type: "Long Indoor Cycling", day: "Tuesday" },
          { type: "HIIT Indoor Cycling", day: "Wednesday" },
          { type: "Outdoor Slow Run", day: "Thursday" },
          { type: "Outdoor Sprint Strides", day: "Saturday" },
        ];
      } else if (trainingDays === 6) {
        sessionConfigs = [
          { type: "Strength Training", day: "Monday" },
          { type: "Long Indoor Cycling", day: "Tuesday" },
          { type: "HIIT Indoor Cycling", day: "Wednesday" },
          { type: "Outdoor Slow Run", day: "Thursday" },
          { type: "HIIT Indoor Cycling", day: "Friday" },
          { type: "Outdoor Sprint Strides", day: "Saturday" },
        ];
      }

      if (eventDate && this.isSameCalendarDay(currentDate, eventDate)) {
        plan[weekIndex].push({
          day: dayName,
          dateLabel: this.formatDate(currentDate),
          type: "EVENT DAY",
          duration: 0,
          description: null,
          exercises: null,
          isTaperWeek: false,
        });
        continue;
      }

      const sessionConfig = sessionConfigs.find((s) => s.day === dayName);

      if (!sessionConfig) {
        plan[weekIndex].push({
          day: dayName,
          dateLabel: this.formatDate(currentDate),
          type: "Rest Day",
          duration: 0,
          description: isTaperWeek ? "Taper week recovery" : null,
          exercises: null,
          isTaperWeek,
        });
        continue;
      }

      let duration = 0;
      let description = null;
      let exercises = null;

      if (sessionConfig.type === "Strength Training") {
        if (isTaperWeek) {
          exercises = window.RunningPlan.STRENGTH_EXERCISES.slice(0, 4);
          description = "Light mobility and activation (taper week)";
        } else {
          exercises = window.RunningPlan.STRENGTH_EXERCISES;
        }
      } else if (sessionConfig.type === "HIIT Indoor Cycling") {
        duration = isTaperWeek ? Math.max(20, Math.round(hiitDuration * 0.6)) : hiitDuration;
        description = isTaperWeek
          ? "Reduced intensity intervals (taper week)"
          : "High Intensity Interval Training";
      } else if (sessionConfig.type === "Long Indoor Cycling") {
        const variability = (weekIndex * 17 + dayOffset * 13) % 11;
        const baseDuration = Math.round((60 + variability) * intensityFactor);
        duration = isTaperWeek ? Math.max(30, Math.round(baseDuration * 0.6)) : baseDuration;
        description = isTaperWeek ? "Steady easy ride (taper week)" : "Steady long ride";
      } else if (sessionConfig.type === "Outdoor Slow Run") {
        if (isTaperWeek) {
          duration = Math.max(20, Math.round(slowRunDuration * 0.5));
          description = "Easy pace (taper week)";
        } else if (daysUntilRace <= 14) {
          duration = Math.max(25, Math.round(slowRunDuration * 0.75));
          description = "Easy pace (pre-taper)";
        } else {
          duration = slowRunDuration;
          description = "Easy pace";
        }
      } else if (sessionConfig.type === "Outdoor Sprint Strides") {
        description = isTaperWeek
          ? "4 x 100m relaxed strides (taper week)"
          : "6 x 200m, rest 2 mins in between";
      }

      plan[weekIndex].push({
        day: dayName,
        dateLabel: this.formatDate(currentDate),
        type: sessionConfig.type,
        duration,
        description,
        exercises,
        isTaperWeek,
      });
    }

    return plan;
  },
};

if (typeof module !== "undefined" && module.exports) {
  module.exports = window.RunningPlan.utils;
}
  </script>

  <script type="text/babel">
window.RunningPlan = window.RunningPlan || {};

const DisclaimerGate = function DisclaimerGate({ onAccept, onDecline }) {
  const [checked, setChecked] = React.useState(false);

  return (
    <div className="mx-auto w-full max-w-[800px] text-left">
      <a
        href="index.html"
        className="mb-8 inline-flex items-center gap-2 text-[1.2em] text-[#444] no-underline"
      >
        <img
          src="../back-arrow.svg"
          alt="Back"
          width="20"
          height="20"
          className="[filter:invert(26%)_sepia(48%)_saturate(603%)_hue-rotate(122deg)_brightness(97%)_contrast(101%)]"
        />{" "}
        Back
      </a>

      <header className="mb-8">
        <h1 className="mb-2 text-5xl font-bold text-brand">Event-Day Run Planner</h1>
        <p className="m-0 text-[1.2em] text-[#444]">Please read before using this tool.</p>
      </header>

      <section className="rounded-xl border border-red-200 bg-red-50 p-6 text-sm leading-relaxed text-red-900">
        <h2 className="mb-4 text-xl font-bold">{window.RunningPlan.DISCLAIMER_TITLE}</h2>
        <div className="space-y-3">
          {window.RunningPlan.DISCLAIMER_LINES.map((line, idx) => (
            <p key={idx} className="m-0">
              {line}
            </p>
          ))}
        </div>

        <label className="mt-6 flex items-start gap-3 rounded-lg border border-red-200 bg-white p-4">
          <input
            type="checkbox"
            className="mt-1 h-4 w-4"
            checked={checked}
            onChange={(e) => setChecked(e.target.checked)}
          />
          <span className="text-sm">
            I have read and understood this disclaimer and I choose to proceed at my own risk.
          </span>
        </label>

        <div className="mt-6 flex flex-wrap gap-3">
          <button
            type="button"
            onClick={onDecline}
            className="rounded-lg border border-gray-300 bg-white px-5 py-2.5 font-semibold text-gray-700 transition hover:bg-gray-100"
          >
            Decline
          </button>
          <button
            type="button"
            disabled={!checked}
            onClick={onAccept}
            className="rounded-lg bg-brand px-5 py-2.5 font-semibold text-white transition hover:bg-brand-dark disabled:cursor-not-allowed disabled:bg-gray-400"
          >
            Accept and continue
          </button>
        </div>
      </section>
    </div>
  );
};

window.RunningPlan.DisclaimerGate = DisclaimerGate;

if (typeof module !== "undefined" && module.exports) {
  module.exports = { DisclaimerGate };
}
  </script>

  <script type="text/babel">
window.RunningPlan = window.RunningPlan || {};

const StepWizard = function StepWizard({
  form,
  daysRemaining,
  validationMessage,
  currentStep,
  onEditStep,
  onDateChange,
  onDistanceChange,
  onExpectedTimeChange,
  onTrainingDaysChange,
  onGenerate,
  canGenerate,
}) {
  const distanceMeta = window.RunningPlan.utils.getDistanceMeta(form.distance);

  const StepSummary = ({ step, label, value }) => (
    <div className="mb-4 flex items-center justify-between rounded-lg border border-gray-200 bg-gray-50 px-4 py-3">
      <div>
        <div className="text-xs uppercase tracking-wide text-gray-500">Step {step}</div>
        <div className="text-sm font-semibold text-gray-800">{label}</div>
        <div className="text-sm text-gray-700">{value}</div>
      </div>
      <button
        type="button"
        onClick={() => onEditStep(step)}
        className="rounded-md border border-gray-300 bg-white p-2 text-gray-700 transition hover:bg-gray-100"
        aria-label={`Edit step ${step}`}
      >
        âœŽ
      </button>
    </div>
  );

  return (
    <div>
      {currentStep > 1 ? (
        <StepSummary
          step={1}
          label="Event date"
          value={`${form.eventDate} (${daysRemaining} days to go)`}
        />
      ) : (
        <section className="mb-8 rounded-lg border border-gray-200 p-5">
          <h2 className="mb-3 text-lg font-bold text-brand">Step 1: Event date</h2>
          <label htmlFor="eventDate" className="mb-2 block text-sm font-semibold text-brand">
            When is your running event?
          </label>
          <input
            type="date"
            id="eventDate"
            value={form.eventDate}
            onChange={(e) => onDateChange(e.target.value)}
            className="w-full rounded-lg border border-gray-200 p-3 text-base"
          />
        </section>
      )}

      {validationMessage === window.RunningPlan.TIME_TRAVEL_MSG && (
        <div className="mb-8 rounded-lg border border-amber-200 bg-amber-50 p-4 text-amber-800">
          {window.RunningPlan.TIME_TRAVEL_MSG}
        </div>
      )}

      {currentStep > 2 ? (
        <StepSummary step={2} label="Distance" value={distanceMeta ? distanceMeta.label : ""} />
      ) : (
        currentStep >= 2 && (
          <section className="mb-8 rounded-lg border border-gray-200 p-5">
            <h2 className="mb-3 text-lg font-bold text-brand">Step 2: Distance</h2>
            <label htmlFor="distance" className="mb-2 block text-sm font-semibold text-brand">
              Choose your distance
            </label>
            <select
              id="distance"
              value={form.distance}
              onChange={(e) => onDistanceChange(e.target.value)}
              className="w-full rounded-lg border border-gray-200 p-3 text-base"
            >
              <option value="">Select distance</option>
              {window.RunningPlan.DISTANCE_OPTIONS.map((distance) => (
                <option key={distance.value} value={distance.value}>
                  {distance.label}
                </option>
              ))}
            </select>
            {daysRemaining !== null &&
              form.distance &&
              validationMessage !== window.RunningPlan.TIME_TRAVEL_MSG && (
                <p className="mt-3 text-sm text-gray-600">
                  Minimum prep for {distanceMeta.label}: {distanceMeta.minDays} days.
                </p>
              )}
          </section>
        )
      )}

      {validationMessage === window.RunningPlan.AMBITIOUS_PLAN_MSG && (
        <div className="mb-8 rounded-lg border border-amber-200 bg-amber-50 p-4 text-amber-800">
          {window.RunningPlan.AMBITIOUS_PLAN_MSG}
        </div>
      )}

      {currentStep > 3 ? (
        <StepSummary step={3} label="Expected finish time" value={form.expectedTime} />
      ) : (
        currentStep >= 3 && (
          <section className="mb-8 rounded-lg border border-gray-200 p-5">
            <h2 className="mb-3 text-lg font-bold text-brand">Step 3: Target time</h2>
            <label htmlFor="expectedTime" className="mb-2 block text-sm font-semibold text-brand">
              Expected finish time (hours:minutes)
            </label>
            <input
              type="text"
              id="expectedTime"
              placeholder="e.g., 1:10 for 10km, 1:45 for half, 4:30 for full"
              value={form.expectedTime}
              onChange={(e) => onExpectedTimeChange(e.target.value)}
              className="w-full rounded-lg border border-gray-200 p-3 text-base"
            />
          </section>
        )
      )}

      {currentStep > 4 ? (
        <StepSummary
          step={4}
          label="Training days per week"
          value={`${form.trainingDaysPerWeek} days`}
        />
      ) : (
        currentStep >= 4 && (
          <section className="mb-8 rounded-lg border border-gray-200 p-5">
            <h2 className="mb-3 text-lg font-bold text-brand">Step 4: Weekly frequency</h2>
            <label htmlFor="trainingDays" className="mb-2 block text-sm font-semibold text-brand">
              How many days per week will you train?
            </label>
            <select
              id="trainingDays"
              value={form.trainingDaysPerWeek}
              onChange={(e) => onTrainingDaysChange(e.target.value)}
              className="w-full rounded-lg border border-gray-200 p-3 text-base"
            >
              <option value="">Select training days</option>
              <option value="3">3 days</option>
              <option value="4">4 days</option>
              <option value="5">5 days</option>
              <option value="6">6 days</option>
            </select>
          </section>
        )
      )}

      {currentStep >= 5 && (
        <button
          type="button"
          onClick={onGenerate}
          disabled={!canGenerate}
          className="w-full rounded-lg bg-brand px-8 py-4 text-base font-semibold text-white transition hover:bg-brand-dark disabled:cursor-not-allowed disabled:bg-gray-400"
        >
          Generate Training Plan
        </button>
      )}
    </div>
  );
};

window.RunningPlan.StepWizard = StepWizard;

if (typeof module !== "undefined" && module.exports) {
  module.exports = { StepWizard };
}
  </script>

  <script type="text/babel">
window.RunningPlan = window.RunningPlan || {};

const { useMemo, useState } = React;

const PlanResults = function PlanResults({
  plan,
  distanceLabel,
  expectedTime,
  daysRemaining,
  onStartOver,
  planName,
  onPlanNameChange,
  onUpdateSession,
  shareUrl,
  onCopyShareUrl,
  copyStatus,
}) {
  const [isEditing, setIsEditing] = useState(false);
  const [activeEditorKey, setActiveEditorKey] = useState(null);

  const editableSessions = useMemo(
    () =>
      plan.flatMap((week, weekIndex) =>
        week.map((session, dayIndex) => ({
          key: `${weekIndex}-${dayIndex}`,
          weekIndex,
          dayIndex,
          label: `Week ${weekIndex + 1} - ${session.day || `Day ${dayIndex + 1}`}`,
        }))
      ),
    [plan]
  );

  const activeEditorIndex = useMemo(() => {
    if (!activeEditorKey) return -1;
    return editableSessions.findIndex((session) => session.key === activeEditorKey);
  }, [editableSessions, activeEditorKey]);

  const activeEditor = activeEditorIndex >= 0 ? editableSessions[activeEditorIndex] : null;
  const activeSession =
    activeEditor && plan[activeEditor.weekIndex]
      ? plan[activeEditor.weekIndex][activeEditor.dayIndex]
      : null;

  const toggleEditing = () => {
    setIsEditing((prev) => {
      const next = !prev;
      if (!next) setActiveEditorKey(null);
      return next;
    });
  };

  const openEditor = (weekIndex, dayIndex) => {
    setActiveEditorKey(`${weekIndex}-${dayIndex}`);
  };

  const closeEditor = () => {
    setActiveEditorKey(null);
  };

  const navigateEditorBy = (offset) => {
    if (activeEditorIndex < 0) return;

    const nextIndex = activeEditorIndex + offset;
    if (nextIndex < 0 || nextIndex >= editableSessions.length) return;

    setActiveEditorKey(editableSessions[nextIndex].key);
  };

  const parseExercises = (value) =>
    value
      ? value
          .split(",")
          .map((item) => item.trim())
          .filter(Boolean)
      : null;

  const renderReadOnlySession = (session) => (
    <>
      <div className="mb-1 text-sm font-semibold text-brand">
        {session.day}
        {session.dateLabel ? ` - ${session.dateLabel}` : ""}
      </div>
      <div className="mb-1 font-semibold">{session.type}</div>

      {Array.isArray(session.exercises) && session.exercises.length > 0 ? (
        <div className="mt-2 text-sm text-[#666]">
          <strong>Exercises:</strong>
          <div className="mt-1">{session.exercises.slice(0, 6).join(", ")}</div>
        </div>
      ) : null}

      {session.description ? (
        <div className="mt-2 text-sm text-[#666]">{session.description}</div>
      ) : null}

      {Number(session.duration) > 0 ? (
        <div className="mt-1 text-sm font-semibold text-[#666]">{session.duration} minutes</div>
      ) : null}
    </>
  );

  return (
    <section className="mt-10 pb-24">
      <div className="mb-6 print:hidden">
        <label htmlFor="planName" className="mb-2 block text-sm font-semibold text-brand">
          Plan name
        </label>
        <input
          id="planName"
          type="text"
          value={planName}
          onChange={(e) => onPlanNameChange(e.target.value)}
          placeholder="e.g., Spring 10k prep"
          className="w-full rounded-lg border border-gray-200 p-3 text-base"
        />
      </div>

      <div className="mb-6 flex flex-wrap items-center gap-3 print:hidden">
        <button
          type="button"
          onClick={toggleEditing}
          className={
            isEditing
              ? "rounded-lg bg-amber-500 px-4 py-2.5 font-semibold text-white transition hover:bg-amber-600"
              : "rounded-lg border border-gray-300 bg-white px-4 py-2.5 font-semibold text-gray-700 transition hover:bg-gray-100"
          }
        >
          {isEditing ? "Done editing" : "Enable edit mode"}
        </button>
        <button
          type="button"
          onClick={() => window.print()}
          className="rounded-lg border border-gray-300 bg-white px-4 py-2.5 font-semibold text-gray-700 transition hover:bg-gray-100"
        >
          Print plan
        </button>
        {isEditing ? (
          <span className="text-sm text-gray-600">
            Pick one card to edit. Use Previous/Next inside the editor panel.
          </span>
        ) : null}
      </div>

      <div className="mb-6 rounded-lg border border-gray-200 bg-white p-4 print:hidden">
        <div className="mb-2 text-sm font-semibold text-brand">Share this plan</div>
        <div className="flex flex-col gap-3 sm:flex-row">
          <input
            type="text"
            readOnly
            value={shareUrl}
            aria-label="Share URL"
            className="w-full rounded-lg border border-gray-200 bg-gray-50 p-3 text-sm text-gray-700"
          />
          <button
            type="button"
            onClick={onCopyShareUrl}
            className="rounded-lg bg-brand px-4 py-2.5 text-sm font-semibold text-white transition hover:bg-brand-dark"
          >
            {copyStatus === "copied" ? "Copied" : "Copy URL"}
          </button>
        </div>
      </div>

      <h2 className="mb-1 text-3xl font-bold text-brand">
        {planName || `Your ${distanceLabel} Plan`}
      </h2>
      <p className="mb-6 text-[#666]">
        Target: {expectedTime} finish time | {daysRemaining} days to race day
      </p>

      {plan.map((week, weekIndex) => {
        const hasTaperWeek = week.some(
          (session) => session.isTaperWeek && session.type !== "EVENT DAY"
        );

        return (
          <div
            key={weekIndex}
            className="mb-6 rounded-lg border border-gray-200 bg-white p-6 break-inside-avoid"
          >
            <div className="mb-4 flex items-center gap-2 text-lg font-bold text-brand">
              <span>Week {weekIndex + 1}</span>
              {hasTaperWeek && (
                <span className="rounded-full bg-amber-100 px-2 py-1 text-xs font-semibold text-amber-700">
                  Taper week
                </span>
              )}
            </div>

            <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
              {week.map((session, dayIndex) => {
                const sessionKey = `${weekIndex}-${dayIndex}`;
                const isSelected = activeEditorKey === sessionKey;

                return (
                  <div
                    key={dayIndex}
                    className={
                      session.type === "EVENT DAY"
                        ? `rounded-md border-l-[3px] border-amber-500 bg-amber-50 p-4 ${
                            isSelected ? "ring-2 ring-amber-400" : ""
                          }`
                        : `rounded-md border-l-[3px] border-brand bg-[#f9fdf7] p-4 ${
                            isSelected ? "ring-2 ring-brand" : ""
                          }`
                    }
                  >
                    {renderReadOnlySession(session)}
                    {isEditing ? (
                      <button
                        type="button"
                        onClick={() => openEditor(weekIndex, dayIndex)}
                        className="mt-3 rounded-md border border-gray-300 bg-white px-3 py-1.5 text-xs font-semibold text-gray-700 transition hover:bg-gray-100"
                        aria-label={`Edit ${session.day || `day ${dayIndex + 1}`}`}
                      >
                        {isSelected ? "Editing" : "Edit day"}
                      </button>
                    ) : null}
                  </div>
                );
              })}
            </div>
          </div>
        );
      })}

      {isEditing && activeSession ? (
        <div className="fixed inset-0 z-40 flex items-end justify-center bg-black/30 p-0 print:hidden sm:items-center sm:p-6">
          <div className="max-h-[90vh] w-full max-w-2xl overflow-y-auto rounded-t-2xl bg-white p-5 shadow-2xl sm:rounded-2xl sm:p-6">
            <div className="mb-4 flex items-start justify-between gap-4">
              <div>
                <h3 className="text-xl font-bold text-brand">Edit training day</h3>
                <p className="m-0 text-sm text-gray-600">
                  {activeEditor.label} ({activeEditorIndex + 1} of {editableSessions.length})
                </p>
              </div>
              <button
                type="button"
                onClick={closeEditor}
                className="rounded-md border border-gray-300 bg-white px-3 py-1.5 text-xs font-semibold text-gray-700 transition hover:bg-gray-100"
              >
                Close editor
              </button>
            </div>

            <div className="mb-4 flex gap-2">
              <button
                type="button"
                onClick={() => navigateEditorBy(-1)}
                disabled={activeEditorIndex <= 0}
                className="rounded-md border border-gray-300 bg-white px-3 py-1.5 text-xs font-semibold text-gray-700 transition hover:bg-gray-100 disabled:cursor-not-allowed disabled:opacity-50"
              >
                Previous day
              </button>
              <button
                type="button"
                onClick={() => navigateEditorBy(1)}
                disabled={activeEditorIndex >= editableSessions.length - 1}
                className="rounded-md border border-gray-300 bg-white px-3 py-1.5 text-xs font-semibold text-gray-700 transition hover:bg-gray-100 disabled:cursor-not-allowed disabled:opacity-50"
              >
                Next day
              </button>
            </div>

            <div className="space-y-4">
              <div className="grid grid-cols-1 gap-3 sm:grid-cols-2">
                <div>
                  <label
                    htmlFor="editor-day"
                    className="mb-1 block text-sm font-semibold text-brand"
                  >
                    Day
                  </label>
                  <input
                    id="editor-day"
                    type="text"
                    value={activeSession.day || ""}
                    onChange={(e) =>
                      onUpdateSession(activeEditor.weekIndex, activeEditor.dayIndex, {
                        day: e.target.value,
                      })
                    }
                    className="w-full rounded border border-gray-200 p-2 text-sm"
                    placeholder="Day"
                  />
                </div>

                <div>
                  <label
                    htmlFor="editor-date"
                    className="mb-1 block text-sm font-semibold text-brand"
                  >
                    Date
                  </label>
                  <input
                    id="editor-date"
                    type="text"
                    value={activeSession.dateLabel || ""}
                    onChange={(e) =>
                      onUpdateSession(activeEditor.weekIndex, activeEditor.dayIndex, {
                        dateLabel: e.target.value,
                      })
                    }
                    className="w-full rounded border border-gray-200 p-2 text-sm"
                    placeholder="Date"
                  />
                </div>
              </div>

              <div>
                <label
                  htmlFor="editor-session-type"
                  className="mb-1 block text-sm font-semibold text-brand"
                >
                  Session type
                </label>
                <input
                  id="editor-session-type"
                  type="text"
                  value={activeSession.type || ""}
                  onChange={(e) =>
                    onUpdateSession(activeEditor.weekIndex, activeEditor.dayIndex, {
                      type: e.target.value,
                    })
                  }
                  className="w-full rounded border border-gray-200 p-2 text-sm"
                  placeholder="Session type"
                />
              </div>

              <div>
                <label
                  htmlFor="editor-duration"
                  className="mb-1 block text-sm font-semibold text-brand"
                >
                  Duration (minutes)
                </label>
                <input
                  id="editor-duration"
                  type="text"
                  value={activeSession.duration ?? ""}
                  onChange={(e) =>
                    onUpdateSession(activeEditor.weekIndex, activeEditor.dayIndex, {
                      duration: e.target.value,
                    })
                  }
                  className="w-full rounded border border-gray-200 p-2 text-sm"
                  placeholder="Duration (minutes)"
                />
              </div>

              <div>
                <label
                  htmlFor="editor-description"
                  className="mb-1 block text-sm font-semibold text-brand"
                >
                  Description / notes
                </label>
                <textarea
                  id="editor-description"
                  value={activeSession.description || ""}
                  onChange={(e) =>
                    onUpdateSession(activeEditor.weekIndex, activeEditor.dayIndex, {
                      description: e.target.value,
                    })
                  }
                  className="w-full rounded border border-gray-200 p-2 text-sm"
                  rows="3"
                  placeholder="Description / notes"
                />
              </div>

              <div>
                <label
                  htmlFor="editor-exercises"
                  className="mb-1 block text-sm font-semibold text-brand"
                >
                  Exercises (comma-separated)
                </label>
                <input
                  id="editor-exercises"
                  type="text"
                  value={
                    Array.isArray(activeSession.exercises) ? activeSession.exercises.join(", ") : ""
                  }
                  onChange={(e) =>
                    onUpdateSession(activeEditor.weekIndex, activeEditor.dayIndex, {
                      exercises: parseExercises(e.target.value),
                    })
                  }
                  className="w-full rounded border border-gray-200 p-2 text-sm"
                  placeholder="Exercises (comma-separated)"
                />
              </div>
            </div>
          </div>
        </div>
      ) : null}

      {isEditing ? (
        <div className="fixed bottom-4 right-4 z-30 print:hidden">
          <button
            type="button"
            onClick={toggleEditing}
            className="rounded-xl bg-amber-500 px-5 py-3 text-sm font-bold text-white shadow-lg transition hover:bg-amber-600"
          >
            Done editing
          </button>
        </div>
      ) : null}

      <button
        type="button"
        className="mt-4 w-full rounded-lg bg-brand px-8 py-4 text-base font-semibold text-white transition hover:bg-brand-dark print:hidden"
        onClick={onStartOver}
      >
        Start Over
      </button>
    </section>
  );
};

window.RunningPlan.PlanResults = PlanResults;

if (typeof module !== "undefined" && module.exports) {
  module.exports = { PlanResults };
}
  </script>

  <script type="text/babel">
window.RunningPlan = window.RunningPlan || {};

const { useMemo, useState } = React;

function MarathonPrepBuilderApp() {
  const [sharedPayload] = useState(() => {
    if (typeof window === "undefined") return null;
    return window.RunningPlan.utils.getSharePayloadFromHash(window.location.hash);
  });

  const hasSharedPlan = Boolean(
    sharedPayload && sharedPayload.plan && Array.isArray(sharedPayload.plan)
  );

  const [disclaimerStatus, setDisclaimerStatus] = useState(hasSharedPlan ? "accepted" : "pending");
  const [currentStep, setCurrentStep] = useState(hasSharedPlan ? 5 : 1);

  const [form, setForm] = useState(() => ({
    eventDate: "",
    distance: "",
    expectedTime: "",
    trainingDaysPerWeek: "",
    ...(sharedPayload && sharedPayload.form ? sharedPayload.form : {}),
  }));

  const [planName, setPlanName] = useState(() =>
    sharedPayload && sharedPayload.planName ? sharedPayload.planName : ""
  );

  const [plan, setPlan] = useState(hasSharedPlan ? sharedPayload.plan : null);
  const [planError, setPlanError] = useState(null);
  const [copyStatus, setCopyStatus] = useState("idle");

  const dateInfo = useMemo(
    () => window.RunningPlan.utils.getDaysRemaining(form.eventDate),
    [form.eventDate]
  );

  const validationMessage = useMemo(
    () =>
      window.RunningPlan.utils.getValidationMessage({
        dateStr: form.eventDate,
        distanceValue: form.distance,
      }),
    [form.eventDate, form.distance]
  );

  const expectedTimeMinutes = useMemo(
    () => window.RunningPlan.utils.parseExpectedTime(form.expectedTime),
    [form.expectedTime]
  );

  const distanceMeta = useMemo(
    () => window.RunningPlan.utils.getDistanceMeta(form.distance),
    [form.distance]
  );

  const canGenerate = Boolean(
    form.eventDate &&
    form.distance &&
    form.trainingDaysPerWeek &&
    expectedTimeMinutes &&
    !validationMessage &&
    dateInfo.daysRemaining !== null &&
    dateInfo.daysRemaining >= 0
  );

  const shareUrl = useMemo(() => {
    if (!plan) return "";

    const fallbackName = distanceMeta
      ? `${distanceMeta.label} plan (${form.eventDate || "undated"})`
      : "Running plan";

    return window.RunningPlan.utils.buildShareUrl({
      v: 1,
      planName: planName || fallbackName,
      form,
      plan,
    });
  }, [plan, planName, form, distanceMeta]);

  const resetAfterStep = (step) => {
    setPlan(null);
    setPlanError(null);
    setCopyStatus("idle");

    setForm((prev) => {
      if (step === 1) {
        return {
          eventDate: prev.eventDate,
          distance: "",
          expectedTime: "",
          trainingDaysPerWeek: "",
        };
      }

      if (step === 2) {
        return { ...prev, expectedTime: "", trainingDaysPerWeek: "" };
      }

      if (step === 3) {
        return { ...prev, trainingDaysPerWeek: "" };
      }

      return prev;
    });
  };

  const handleDateChange = (value) => {
    setForm((prev) => ({ ...prev, eventDate: value }));
    resetAfterStep(1);

    const dateValidation = window.RunningPlan.utils.getValidationMessage({
      dateStr: value,
      distanceValue: "",
    });

    if (value && !dateValidation) {
      setCurrentStep(2);
    } else {
      setCurrentStep(1);
    }
  };

  const handleDistanceChange = (value) => {
    setForm((prev) => ({ ...prev, distance: value }));
    resetAfterStep(2);

    const nextValidation = window.RunningPlan.utils.getValidationMessage({
      dateStr: form.eventDate,
      distanceValue: value,
    });

    if (value && !nextValidation) {
      setCurrentStep(3);
    } else {
      setCurrentStep(2);
    }
  };

  const handleExpectedTimeChange = (value) => {
    setForm((prev) => ({ ...prev, expectedTime: value }));
    resetAfterStep(3);

    if (window.RunningPlan.utils.parseExpectedTime(value)) {
      setCurrentStep(4);
    } else {
      setCurrentStep(3);
    }
  };

  const handleTrainingDaysChange = (value) => {
    setForm((prev) => ({ ...prev, trainingDaysPerWeek: value }));
    setPlan(null);
    setPlanError(null);
    setCopyStatus("idle");

    if (value) {
      setCurrentStep(5);
    } else {
      setCurrentStep(4);
    }
  };

  const handleEditStep = (step) => {
    setCurrentStep(step);
    resetAfterStep(step);
  };

  const handleGeneratePlan = () => {
    if (validationMessage) {
      setPlan(null);
      setPlanError(validationMessage);
      return;
    }

    if (!canGenerate) {
      return;
    }

    if (!distanceMeta || dateInfo.daysRemaining < distanceMeta.minDays) {
      setPlan(null);
      setPlanError(window.RunningPlan.AMBITIOUS_PLAN_MSG);
      return;
    }

    const generated = window.RunningPlan.utils.buildWeeklyPlan({
      eventDateStr: form.eventDate,
      expectedTimeMinutes,
      trainingDaysPerWeek: form.trainingDaysPerWeek,
    });

    setPlan(generated);
    setPlanError(null);
    setCopyStatus("idle");

    if (!planName && distanceMeta) {
      setPlanName(`${distanceMeta.label} plan (${form.eventDate})`);
    }
  };

  const handleUpdateSession = (weekIndex, dayIndex, patch) => {
    setPlan((prevPlan) => {
      if (!Array.isArray(prevPlan)) return prevPlan;

      return prevPlan.map((week, wi) => {
        if (wi !== weekIndex) return week;

        return week.map((session, di) => {
          if (di !== dayIndex) return session;
          return { ...session, ...patch };
        });
      });
    });

    setCopyStatus("idle");
  };

  const handleCopyShareUrl = async () => {
    if (!shareUrl) return;

    try {
      if (
        typeof navigator !== "undefined" &&
        navigator.clipboard &&
        typeof navigator.clipboard.writeText === "function"
      ) {
        await navigator.clipboard.writeText(shareUrl);
      } else {
        if (typeof window !== "undefined") {
          window.prompt("Copy this URL:", shareUrl);
        }
      }

      setCopyStatus("copied");
      setTimeout(() => setCopyStatus("idle"), 2000);
    } catch (_error) {
      setCopyStatus("idle");
    }
  };

  const handleStartOver = () => {
    setPlan(null);
    setPlanError(null);
    setCurrentStep(1);
    setPlanName("");
    setCopyStatus("idle");
    setForm({ eventDate: "", distance: "", expectedTime: "", trainingDaysPerWeek: "" });
  };

  const navigateToToolsIndex = () => {
    if (typeof window === "undefined") return;

    if (typeof window.__RUNNING_PLAN_NAVIGATE__ === "function") {
      window.__RUNNING_PLAN_NAVIGATE__("index.html");
      return;
    }

    if (window.location && typeof window.location.assign === "function") {
      window.location.assign("index.html");
    }
  };

  if (disclaimerStatus === "pending") {
    return (
      <window.RunningPlan.DisclaimerGate
        onAccept={() => setDisclaimerStatus("accepted")}
        onDecline={navigateToToolsIndex}
      />
    );
  }

  return (
    <div className="mx-auto w-full max-w-[900px] text-left">
      <a
        href="index.html"
        className="mb-8 inline-flex items-center gap-2 text-[1.2em] text-[#444] no-underline print:hidden"
      >
        <img
          src="../back-arrow.svg"
          alt="Back"
          width="20"
          height="20"
          className="[filter:invert(26%)_sepia(48%)_saturate(603%)_hue-rotate(122deg)_brightness(97%)_contrast(101%)]"
        />{" "}
        Back
      </a>

      <div className="mb-6 rounded-lg border border-emerald-200 bg-emerald-50 p-4 text-emerald-800">
        {window.RunningPlan.RISK_ACCEPTED_BANNER}
      </div>

      <header className="mb-8">
        <h1 className="mb-2 text-5xl font-bold text-brand">Event-Day Run Planner</h1>
        <p className="m-0 text-[1.2em] text-[#444]">Plan your running event</p>
      </header>

      {!plan && (
        <window.RunningPlan.StepWizard
          form={form}
          daysRemaining={dateInfo.daysRemaining}
          validationMessage={validationMessage}
          currentStep={currentStep}
          onEditStep={handleEditStep}
          onDateChange={handleDateChange}
          onDistanceChange={handleDistanceChange}
          onExpectedTimeChange={handleExpectedTimeChange}
          onTrainingDaysChange={handleTrainingDaysChange}
          onGenerate={handleGeneratePlan}
          canGenerate={canGenerate}
        />
      )}

      {planError && !plan && (
        <div className="mt-6 rounded-lg border border-amber-200 bg-amber-50 p-4 text-amber-800">
          {planError}
        </div>
      )}

      {plan && (
        <window.RunningPlan.PlanResults
          plan={plan}
          distanceLabel={distanceMeta ? distanceMeta.label : "Race"}
          expectedTime={form.expectedTime}
          daysRemaining={dateInfo.daysRemaining}
          onStartOver={handleStartOver}
          planName={planName}
          onPlanNameChange={(value) => {
            setPlanName(value);
            setCopyStatus("idle");
          }}
          onUpdateSession={handleUpdateSession}
          shareUrl={shareUrl}
          onCopyShareUrl={handleCopyShareUrl}
          copyStatus={copyStatus}
        />
      )}
    </div>
  );
}

window.RunningPlan.MarathonPrepBuilderApp = MarathonPrepBuilderApp;

if (typeof module !== "undefined" && module.exports) {
  module.exports = { MarathonPrepBuilderApp };
}

if (typeof document !== "undefined") {
  const rootElement = document.getElementById("root");
  if (rootElement && typeof ReactDOM !== "undefined") {
    ReactDOM.render(<MarathonPrepBuilderApp />, rootElement);
  }
}
  </script>
</body>
</html>
